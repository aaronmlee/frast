#include "detail/env.h"
#include "coordinates.h"

#include <cassert>


namespace frast {

	// class InnerNode;

	constexpr uint64_t INVALID_OFFSET = 0xfffffffffffffffff;

	//
	// The idea is to have one file but *two* mmaps/environments.
	// This makes memory management easier.
	//
	// ACTUALLY: Does it?
	// How about just having two linked lists: 1 for keys, 1 for values...
	// The link is not a pointer, but a byte offset from the start of the mmap...

	// A fixed size	header segment. Should be put at offset=0 of the file.
	class DatasetHeaderEnvironment : public ArenaEnvironment {

		public:

		static constexpr size_t jsonSize = 16384;
		static constexpr size_t rootTableSize = sizeof(void*) * 26;
		static constexpr size_t totalSize = jsonSize + rootTableSize;

		DatasetHeaderEnvironment(const std::string& path, const EnvOptions& opts);
		~DatasetHeaderEnvironment();

		void initializeEmpty();

		inline char* jsonPart() { return static_cast<char*>(basePointer); }
		inline void setRootOffset(int lvl, int64_t off) {
			reinterpret_cast<int64_t*>(jsonPart()+jsonSize)[lvl] = off;
		}
		inline uint64_t rootOffset(int lvl) {
			assert(lvl >= 0);
			assert(lvl  < MAX_LVLS);
			return reinterpret_cast<uint64_t*>(jsonPart()+jsonSize)[lvl];
		}

	};

	// A dynamic size header segment. Should be put at an offset *after* the header.
	class FlatWriterEnvironment : public ArenaEnvironment {
		public:

		FlatWriterEnvironment(const std::string& path, const EnvOptions& opts);
		~FlatWriterEnvironment();

	};



	static EnvOptions modifyOptionsForDatasetHeader(const EnvOptions& opts_) {
		auto opts = opts_;
		return opts;
	}

	static EnvOptions modifyOptionsForDatasetWriter(const EnvOptions& opts_) {
		auto opts = opts_;
		assert(opts.mapOffset == 0 && "offset should be zero, we will set it based on header size.");
		opts.mapOffset = DatasetHeaderEnvironment::totalSize;
		return opts;
	}

	DatasetHeaderEnvironment::DatasetHeaderEnvironment(const std::string& path, const EnvOptions& opts)
		: ArenaEnvironment(path, modifyOptionsForDatasetHeader(opts))
	{
		if (head == 0) {
			fmt::print(" - DatasetHeaderEnv had head == zero, so this must be new. Setting it up.\n");
			initializeEmpty();
		} else if (head != totalSize) {
			fmt::print(" - DatasetHeaderEnv MUST have head=0 or head=totalSize (which is {}). Was {}\n", totalSize, head);
			assert(false);
		} else {
			// Nothing to do, we can access fields directly.
		}
	}

	void DatasetHeaderEnvironment::initializeEmpty() {
		allocateBytes(totalSize);
		assert(head == totalSize);

		bzero(basePointer, totalSize);

		for (int i=0; i<MAX_LVLS; i++)
			headEnv.setRootOffset(INVALID_OFFSET);

	}





	class FlatWriter {

		public:

			FlatWriter(const std::string& path);

		private:

			DatasetHeaderEnvironment headEnv;
			FlatWriterEnvironment dataEnv;

			bool doesLevelExist(int lvl);
			RootNode* createLevel(int lvl);

	};

	FlatWriter::FlatWriter(const std::string& path) :
		headEnv(path, EnvOptions{}),
		dataEnv(path, EnvOptions{})
	{
	}

	bool FlatWriter::doesLevelExist(int lvl) {
		return headEnv.rootOffset(lvl) != INVALID_OFFSET;
	}

	RootNode* FlatWriter::createLevel(int lvl) {
		return headEnv.rootOffset(lvl) != INVALID_OFFSET;
	}


}
